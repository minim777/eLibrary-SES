<<<<<<< HEAD
**Installation**: `npm install sift`, or `yarn add sift`

## Sift is a tiny library for using MongoDB queries in Javascript

[![Build Status](https://secure.travis-ci.org/crcn/sift.js.png)](https://secure.travis-ci.org/crcn/sift.js)

=======
## validate objects & filter arrays with mongodb queries
[![Build Status](https://secure.travis-ci.org/crcn/sift.js.png)](https://secure.travis-ci.org/crcn/sift.js) 
>>>>>>> origin/Add_Remove_Update_Books
<!-- [![Coverage Status](https://coveralls.io/repos/crcn/sift.js/badge.svg)](https://coveralls.io/r/crcn/sift.js)  -->
<!-- [![Join the chat at https://gitter.im/crcn/sift.js](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/crcn/sift.js?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge) -->

**For extended documentation, checkout http://docs.mongodb.org/manual/reference/operator/query/**

## Features:

<<<<<<< HEAD
- Supported operators: [\$in](#in), [\$nin](#nin), [\$exists](#exists), [\$gte](#gte), [\$gt](#gt), [\$lte](#lte), [\$lt](#lt), [\$eq](#eq), [\$ne](#ne), [\$mod](#mod), [\$all](#all), [\$and](#and), [\$or](#or), [\$nor](#nor), [\$not](#not), [\$size](#size), [\$type](#type), [\$regex](#regex), [\$where](#where), [\$elemMatch](#elemmatch)
- Regexp searches
- Supports node.js, and web
- Custom Operations
- Tree-shaking (omitting functionality from web app bundles)

## Examples

```javascript
import sift from "sift";

//intersecting arrays
const result1 = ["hello", "sifted", "array!"].filter(
  sift({ $in: ["hello", "world"] })
); //['hello']

//regexp filter
const result2 = ["craig", "john", "jake"].filter(sift(/^j/)); //['john','jake']

// function filter
const testFilter = sift({
  //you can also filter against functions
  name: function(value) {
    return value.length == 5;
  }
});

const result3 = [
  {
    name: "craig"
  },
  {
    name: "john"
  },
  {
    name: "jake"
  }
].filter(testFilter); // filtered: [{ name: 'craig' }]

//you can test *single values* against your custom sifter
testFilter({ name: "sarah" }); //true
testFilter({ name: "tim" }); //false
```

## API

### sift(query: MongoQuery, options?: Options): Function

Creates a filter with all of the built-in MongoDB query operations.

- `query` - the filter to use against the target array
- `options`
  - `operations` - [custom operations](#custom-operations)
  - `compare` - compares difference between two values

Example:

```javascript
import sift from "sift";

const test = sift({ $gt: 5 }));

console.log(test(6)); // true
console.log(test(4)); // false

[3, 4, 5, 6, 7].filter(sift({ $exists: true })); // [6, 7]
```

### createQueryTester(query: Query, options?: Options): Function

Creates a filter function **without** built-in MongoDB query operations. This is useful
if you're looking to omit certain operations from application bundles. See [Omitting built-in operations](#omitting-built-in-operations) for more info.

```javascript
import { createQueryTester, $eq, $in } from "sift";
const filter = createQueryTester({ $eq: 5 }, { operations: { $eq, $in } });
```

### createEqualsOperation(params: any, ownerQuery: Query, options: Options): Operation

Used for [custom operations](#custom-operations).

```javascript
import { createQueryTester, createEqualsOperation, $eq, $in } from "sift";
const filter = createQueryTester(
  { $mod: 5 },
  {
    operations: {
      $something(mod, ownerQuery, options) {
        return createEqualsOperation(
          value => value % mod === 0,
          ownerQuery,
          options
        );
      }
    }
  }
);
filter(10); // true
filter(11); // false
```

## Supported Operators

See MongoDB's [advanced queries](http://www.mongodb.org/display/DOCS/Advanced+Queries) for more info.

### \$in

array value must be _\$in_ the given query:
=======
- Supported operators: [$in](#in), [$nin](#nin), [$exists](#exists), [$gte](#gte), [$gt](#gt), [$lte](#lte), [$lt](#lt), [$eq](#eq), [$ne](#ne), [$mod](#mod), [$all](#all), [$and](#and), [$or](#or), [$nor](#nor), [$not](#not), [$size](#size), [$type](#type), [$regex](#regex), [$where](#where), [$elemMatch](#elemmatch)
- Regexp searches
- Function filtering
- sub object searching
- dot notation searching
- Supports node.js, and web
- Small (2 kb minified) library
- Custom Expressions
- filtering of immutable datastructures



## Node.js Examples

```javascript

import sift from 'sift';

//intersecting arrays
var sifted = sift({ $in: ['hello','world'] }, ['hello','sifted','array!']); //['hello']

//regexp filter
var sifted = sift(/^j/, ['craig','john','jake']); //['john','jake']


//A *sifter* is returned if the second parameter is omitted
var testQuery = sift({

	//you can also filter against functions
	name: function(value) {
		return value.length == 5;
	}
});

//filtered: [{ name: 'craig' }]
[{
	name: 'craig',
},
{
	name: 'john'
},
{
	name: 'jake'
}].filter(testQuery);


//you can test *single values* against your custom sifter
testQuery({ name: 'sarah' }); //true
testQuery({ name: 'tim' }); //false\
```

## Browser Examples
```html
<html>
	<head>
		<script src="https://raw.github.com/crcn/sift.js/master/sift.min.js" type="text/javascript"></script>
		<script type="text/javascript">
			//regexp filter
			var sifted = sift(/^j/, ['craig','john','jake']); //['john','jake']
		</script>
	</head>
	<body>
	</body>
</html>
```

## API

### .sift(filter[, array][, selectorFn])

- `filter` - the filter to use against the target array
- `array` - sifts against target array. Without this, a function is returned
- `selectorFn` - selector for the values within the array.

With an array:

```javascript
sift({$exists:true}, ['craig',null]); //['craig']
```

Without an array, a sifter is returned:

```javascript
var siftExists = sift({$exists:true});

siftExists('craig'); //true
siftExists(null); //false
['craig',null].filter(siftExists); //['craig']
```

With a selector:

```javascript
var sifter = sift({$exists:true}, function(user) {
	return !!user.name;
});


sifter([
	{
		name: "Craig"
	},
	{
		name: null
	}
])
```

With your sifter, you can also **test** values:

```javascript
siftExists(null); //false
siftExists('craig'); //true
```


## Supported Operators:

See MongoDB's [advanced queries](http://www.mongodb.org/display/DOCS/Advanced+Queries) for more info.

### $in

array value must be *$in* the given query:
>>>>>>> origin/Add_Remove_Update_Books

Intersecting two arrays:

```javascript
//filtered: ['Brazil']
<<<<<<< HEAD
["Brazil", "Haiti", "Peru", "Chile"].filter(
  sift({ $in: ["Costa Rica", "Brazil"] })
);
```

Here's another example. This acts more like the \$or operator:

```javascript
[{ name: "Craig", location: "Brazil" }].filter(
  sift({ location: { $in: ["Costa Rica", "Brazil"] } })
);
```

### \$nin

Opposite of \$in:

```javascript
//filtered: ['Haiti','Peru','Chile']
["Brazil", "Haiti", "Peru", "Chile"].filter(
  sift({ $nin: ["Costa Rica", "Brazil"] })
);
```

### \$exists
=======
sift({ $in: ['Costa Rica','Brazil'] }, ['Brazil','Haiti','Peru','Chile']);
```

Here's another example. This acts more like the $or operator:

```javascript
sift({ location: { $in: ['Costa Rica','Brazil'] } }, [ { name: 'Craig', location: 'Brazil' } ]);
```

### $nin

Opposite of $in:

```javascript
//filtered: ['Haiti','Peru','Chile']
sift({ $nin: ['Costa Rica','Brazil'] }, ['Brazil','Haiti','Peru','Chile']);
```

### $exists
>>>>>>> origin/Add_Remove_Update_Books

Checks if whether a value exists:

```javascript
//filtered: ['Craig','Tim']
<<<<<<< HEAD
sift({ $exists: true })(["Craig", null, "Tim"]);
=======
sift({ $exists: true }, ['Craig',null,'Tim']);
>>>>>>> origin/Add_Remove_Update_Books
```

You can also filter out values that don't exist

```javascript
<<<<<<< HEAD
//filtered: [{ name: "Tim" }]
[{ name: "Craig", city: "Minneapolis" }, { name: "Tim" }].filter(
  sift({ city: { $exists: false } })
);
```

### \$gte
=======
//filtered: [{ name: 'Craig', city: 'Minneapolis' }]
sift({ city: { $exists: false } }, [ { name: 'Craig', city: 'Minneapolis' }, { name: 'Tim' }]);
```

### $gte
>>>>>>> origin/Add_Remove_Update_Books

Checks if a number is >= value:

```javascript
//filtered: [2, 3]
<<<<<<< HEAD
[0, 1, 2, 3].filter(sift({ $gte: 2 }));
```

### \$gt
=======
sift({ $gte: 2 }, [0, 1, 2, 3]);
```

### $gt
>>>>>>> origin/Add_Remove_Update_Books

Checks if a number is > value:

```javascript
//filtered: [3]
<<<<<<< HEAD
[0, 1, 2, 3].filter(sift({ $gt: 2 }));
```

### \$lte
=======
sift({ $gt: 2 }, [0, 1, 2, 3]);
```

### $lte
>>>>>>> origin/Add_Remove_Update_Books

Checks if a number is <= value.

```javascript
//filtered: [0, 1, 2]
<<<<<<< HEAD
[0, 1, 2, 3].filter(sift({ $lte: 2 }));
```

### \$lt
=======
sift({ $lte: 2 }, [0, 1, 2, 3]);
```

### $lt
>>>>>>> origin/Add_Remove_Update_Books

Checks if number is < value.

```javascript
//filtered: [0, 1]
<<<<<<< HEAD
[0, 1, 2, 3].filter(sift({ $lt: 2 }));
```

### \$eq

Checks if `query === value`. Note that **\$eq can be omitted**. For **\$eq**, and **\$ne**

```javascript
//filtered: [{ state: 'MN' }]
[{ state: "MN" }, { state: "CA" }, { state: "WI" }].filter(
  sift({ state: { $eq: "MN" } })
);
=======
sift({ $lt: 2 }, [0, 1, 2, 3]);
```

### $eq

Checks if `query === value`. Note that **$eq can be omitted**. For **$eq**, and **$ne**

```javascript
//filtered: [{ state: 'MN' }]
sift({ state: {$eq: 'MN' }}, [{ state: 'MN' }, { state: 'CA' }, { state: 'WI' }]);
>>>>>>> origin/Add_Remove_Update_Books
```

Or:

```javascript
//filtered: [{ state: 'MN' }]
<<<<<<< HEAD
[{ state: "MN" }, { state: "CA" }, { state: "WI" }].filter(
  sift({ state: "MN" })
);
```

### \$ne
=======
sift({ state: 'MN' }, [{ state: 'MN' }, { state: 'CA' }, { state: 'WI' }]);
```

### $ne
>>>>>>> origin/Add_Remove_Update_Books

Checks if `query !== value`.

```javascript
//filtered: [{ state: 'CA' }, { state: 'WI'}]
<<<<<<< HEAD
[{ state: "MN" }, { state: "CA" }, { state: "WI" }].filter(
  sift({ state: { $ne: "MN" } })
);
```

### \$mod
=======
sift({ state: {$ne: 'MN' }}, [{ state: 'MN' }, { state: 'CA' }, { state: 'WI' }]);
```

### $mod
>>>>>>> origin/Add_Remove_Update_Books

Modulus:

```javascript
//filtered: [300, 600]
<<<<<<< HEAD
[100, 200, 300, 400, 500, 600].filter(sift({ $mod: [3, 0] }));
```

### \$all
=======
sift({ $mod: [3, 0] }, [100, 200, 300, 400, 500, 600]);
```

### $all
>>>>>>> origin/Add_Remove_Update_Books

values must match **everything** in array:

```javascript
//filtered: [ { tags: ['books','programming','travel' ]} ]
<<<<<<< HEAD
[
  { tags: ["books", "programming", "travel"] },
  { tags: ["travel", "cooking"] }
].filter(sift({ tags: { $all: ["books", "programming"] } }));
```

### \$and
=======
sift({ tags: {$all: ['books','programming'] }}, [
{ tags: ['books','programming','travel' ] },
{ tags: ['travel','cooking'] } ]);
```

### $and
>>>>>>> origin/Add_Remove_Update_Books

ability to use an array of expressions. All expressions must test true.

```javascript
//filtered: [ { name: 'Craig', state: 'MN' }]

<<<<<<< HEAD
[
  { name: "Craig", state: "MN" },
  { name: "Tim", state: "MN" },
  { name: "Joe", state: "CA" }
].filter(sift({ $and: [{ name: "Craig" }, { state: "MN" }] }));
```

### \$or
=======
sift({ $and: [ { name: 'Craig' }, { state: 'MN' } ] }, [
{ name: 'Craig', state: 'MN' },
{ name: 'Tim', state: 'MN' },
{ name: 'Joe', state: 'CA' } ]);
```

### $or
>>>>>>> origin/Add_Remove_Update_Books

OR array of expressions.

```javascript
//filtered: [ { name: 'Craig', state: 'MN' }, { name: 'Tim', state: 'MN' }]
<<<<<<< HEAD
[
  { name: "Craig", state: "MN" },
  { name: "Tim", state: "MN" },
  { name: "Joe", state: "CA" }
].filter(sift({ $or: [{ name: "Craig" }, { state: "MN" }] }));
```

### \$nor
=======
sift({ $or: [ { name: 'Craig' }, { state: 'MN' } ] }, [
{ name: 'Craig', state: 'MN' },
{ name: 'Tim', state: 'MN' },
{ name: 'Joe', state: 'CA' } ]);
```

### $nor
>>>>>>> origin/Add_Remove_Update_Books

opposite of or:

```javascript
//filtered: [ { name: 'Tim', state: 'MN' }, { name: 'Joe', state: 'CA' }]
<<<<<<< HEAD
[
  { name: "Craig", state: "MN" },
  { name: "Tim", state: "MN" },
  { name: "Joe", state: "CA" }
].filter(sift({ $nor: [{ name: "Craig" }, { state: "MN" }] }));
```

### \$size
=======
sift({ $nor: [ { name: 'Craig' }, { state: 'MN' } ] }, [
{ name: 'Craig', state: 'MN' },
{ name: 'Tim', state: 'MN' },
{ name: 'Joe', state: 'CA' } ]);
```


### $size
>>>>>>> origin/Add_Remove_Update_Books

Matches an array - must match given size:

```javascript
//filtered: ['food','cooking']
<<<<<<< HEAD
[{ tags: ["food", "cooking"] }, { tags: ["traveling"] }].filter(
  sift({ tags: { $size: 2 } })
);
```

### \$type
=======
sift({ tags: { $size: 2 } }, [ { tags: ['food','cooking'] }, { tags: ['traveling'] }]);
```

### $type
>>>>>>> origin/Add_Remove_Update_Books

Matches a values based on the type

```javascript
<<<<<<< HEAD
[new Date(), 4342, "hello world"].filter(sift({ $type: Date })); //returns single date
[new Date(), 4342, "hello world"].filter(sift({ $type: String })); //returns ['hello world']
```

### \$regex
=======
sift({ $type: Date }, [new Date(), 4342, 'hello world']); //returns single date
sift({ $type: String }, [new Date(), 4342, 'hello world']); //returns ['hello world']
```

### $regex
>>>>>>> origin/Add_Remove_Update_Books

Matches values based on the given regular expression

```javascript
<<<<<<< HEAD
["frank", "fred", "sam", "frost"].filter(
  sift({ $regex: /^f/i, $nin: ["frank"] })
); // ["fred", "frost"]
["frank", "fred", "sam", "frost"].filter(
  sift({ $regex: "^f", $options: "i", $nin: ["frank"] })
); // ["fred", "frost"]
```

### \$where
=======
sift({ $regex: /^f/i, $nin: ["frank"] }, ["frank", "fred", "sam", "frost"]); // ["fred", "frost"]
sift({ $regex: "^f", $options: "i", $nin: ["frank"] }, ["frank", "fred", "sam", "frost"]); // ["fred", "frost"]
```

### $where
>>>>>>> origin/Add_Remove_Update_Books

Matches based on some javascript comparison

```javascript
<<<<<<< HEAD
[{ name: "frank" }, { name: "joe" }].filter(
  sift({ $where: "this.name === 'frank'" })
); // ["frank"]
[{ name: "frank" }, { name: "joe" }].filter(
  sift({
    $where: function() {
      return this.name === "frank";
    }
  })
); // ["frank"]
```

### \$elemMatch
=======
sift({ $where: "this.name === 'frank'" }, [{name:'frank'},{name:'joe'}]); // ["frank"]
sift({
	$where: function() {
		return this.name === "frank"
	}
}, [{name:'frank'},{name:'joe'}]); // ["frank"]
```

### $elemMatch
>>>>>>> origin/Add_Remove_Update_Books

Matches elements of array

```javascript
<<<<<<< HEAD
var bills = [
  {
    month: "july",
    casts: [
      {
        id: 1,
        value: 200
      },
      {
        id: 2,
        value: 1000
      }
    ]
  },
  {
    month: "august",
    casts: [
      {
        id: 3,
        value: 1000
      },
      {
        id: 4,
        value: 4000
      }
    ]
  }
];

var result = bills.filter(
  sift({
    casts: {
      $elemMatch: {
        value: { $gt: 1000 }
      }
    }
  })
); // {month:'august', casts:[{id:3, value: 1000},{id: 4, value: 4000}]}
```

### \$not
=======
var bills = [{
    month: 'july',
    casts: [{
        id: 1,
        value: 200
    },{
        id: 2,
        value: 1000
    }]
},
{
    month: 'august',
    casts: [{
        id: 3,
        value: 1000,
    }, {
        id: 4,
        value: 4000
    }]
}];

var result = sift({
    casts: {$elemMatch:{
        value: {$gt: 1000}
    }}
}, bills); // {month:'august', casts:[{id:3, value: 1000},{id: 4, value: 4000}]}
```

### $not
>>>>>>> origin/Add_Remove_Update_Books

Not expression:

```javascript
<<<<<<< HEAD
["craig", "tim", "jake"].filter(sift({ $not: { $in: ["craig", "tim"] } })); //['jake']
["craig", "tim", "jake"].filter(sift({ $not: { $size: 5 } })); //['tim','jake']
```

### Date comparison

Mongodb allows you to do date comparisons like so:

```javascript
db.collection.find({ createdAt: { $gte: "2018-03-22T06:00:00Z" } });
```

In Sift, you'll need to specify a Date object:

```javascript
collection.find(
  sift({ createdAt: { $gte: new Date("2018-03-22T06:00:00Z") } })
);
```

## Custom behavior

Sift works like MongoDB out of the box, but you're also able to modify the behavior to suite your needs.

#### Custom operations

You can register your own custom operations. Here's an example:

```javascript
import sift, { createEqualsOperation } from "sift";

var filter = sift(
  {
    $customMod: 2
  },
  {
    operations: {
      $customMod(params, ownerQuery, options) {
        return createEqualsOperation(
          value => value % params !== 0,
          ownerQuery,
          options
        );
      }
    }
  }
);

[1, 2, 3, 4, 5].filter(filter); // 1, 3, 5
```

#### Omitting built-in operations

You can create a filter function that omits the built-in operations like so:

```javascript
import { createQueryTester, $in, $all, $nin, $lt } from "sift";
const test = createQueryTester(
  {
    $eq: 10
  },
  { $in, $all, $nin, $lt }
);

[1, 2, 3, 4, 10].filter(test);
```

For bundlers like `Webpack` and `Rollup`, operations that aren't used are omitted from application bundles via tree-shaking.
=======
sift({$not:{$in:['craig','tim']}}, ['craig','tim','jake']); //['jake']
sift({$not:{$size:5}}, ['craig','tim','jake']); //['tim','jake']
```

## sub object Searching


```javascript
var people = [{
	name: 'craig',
	address: {
		city: 'Minneapolis'
	}
},
{
	name: 'tim',
	address: {
		city: 'St. Paul'
	}
}];

var sifted = sift({ address: { city: 'Minneapolis' }}, people); // count = 1

//or
var sifted = sift({'address.city': 'minneapolis'}, people);//count = 1
```


## Get index of first matching element

Get the index (0-based) of first matching element in target array. Returns `-1` if no match is found.

```javascript
import {indexOf as siftIndexOf} from 'sift';
var people = [{
	name: 'craig',
	address: {
		city: 'Minneapolis'
	}
},
{
	name: 'tim',
	address: {
		city: 'St. Paul'
	}
}];

var index = siftIndexOf({ address: { city: 'Minneapolis' }}, people); // index = 0
```
>>>>>>> origin/Add_Remove_Update_Books
